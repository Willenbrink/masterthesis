
@inproceedings{haller_lacasa_2016,
	location = {New York, {NY}, {USA}},
	title = {{LaCasa}: lightweight affinity and object capabilities in Scala},
	isbn = {978-1-4503-4444-9},
	url = {https://doi.org/10.1145/2983990.2984042},
	doi = {10.1145/2983990.2984042},
	series = {{OOPSLA} 2016},
	shorttitle = {{LaCasa}},
	abstract = {Aliasing is a known source of challenges in the context of imperative object-oriented languages, which have led to important advances in type systems for aliasing control. However, their large-scale adoption has turned out to be a surprisingly difficult challenge. While new language designs show promise, they do not address the need of aliasing control in existing languages. This paper presents a new approach to isolation and uniqueness in an existing, widely-used language, Scala. The approach is unique in the way it addresses some of the most important obstacles to the adoption of type system extensions for aliasing control. First, adaptation of existing code requires only a minimal set of annotations. Only a single bit of information is required per class. Surprisingly, the paper shows that this information can be provided by the object-capability discipline, widely-used in program security. We formalize our approach as a type system and prove key soundness theorems. The type system is implemented for the full Scala language, providing, for the first time, a sound integration with Scala's local type inference. Finally, we empirically evaluate the conformity of existing Scala open-source code on a corpus of over 75,000 {LOC}.},
	pages = {272--291},
	booktitle = {Proceedings of the 2016 {ACM} {SIGPLAN} International Conference on Object-Oriented Programming, Systems, Languages, and Applications},
	publisher = {Association for Computing Machinery},
	author = {Haller, Philipp and Loiko, Alex},
	urldate = {2024-05-13},
	date = {2016-10-19},
	keywords = {Aliasing, object capabilities, Scala, uniqueness},
	file = {Submitted Version:/home/sewi/Zotero/storage/3MUI4N2C/Haller and Loiko - 2016 - LaCasa lightweight affinity and object capabiliti.pdf:application/pdf},
}

@inproceedings{boyapati_parameterized_2001,
	title = {A Parameterized Type System for Race-Free Java Programs},
	url = {https://doi.org/10.1145/504282.504287},
	doi = {10.1145/504282.504287},
	pages = {56--69},
	booktitle = {Proceedings of the 2001 {ACM} {SIGPLAN} Conference on Object-Oriented Programming Systems, Languages and Applications, {OOPSLA} 2001, Tampa, Florida, {USA}, October 14-18, 2001},
	publisher = {{ACM}},
	author = {Boyapati, Chandrasekhar and Rinard, Martin C.},
	editor = {Northrop, Linda M. and Vlissides, John M.},
	date = {2001},
}

@inproceedings{boyapati_ownership_2002,
	title = {Ownership types for safe programming: preventing data races and deadlocks},
	url = {https://doi.org/10.1145/582419.582440},
	doi = {10.1145/582419.582440},
	pages = {211--230},
	booktitle = {Proceedings of the 2002 {ACM} {SIGPLAN} Conference on Object-Oriented Programming Systems, Languages and Applications, {OOPSLA} 2002, Seattle, Washington, {USA}, November 4-8, 2002},
	publisher = {{ACM}},
	author = {Boyapati, Chandrasekhar and Lee, Robert and Rinard, Martin C.},
	editor = {Ibrahim, Mamdouh and Matsuoka, Satoshi},
	date = {2002},
}

@inproceedings{srinivasan_kilim_2008,
	title = {Kilim: Isolation-Typed Actors for Java},
	volume = {5142},
	url = {https://doi.org/10.1007/978-3-540-70592-5\_6},
	doi = {10.1007/978-3-540-70592-5_6},
	series = {Lecture Notes in Computer Science},
	pages = {104--128},
	booktitle = {{ECOOP} 2008 - Object-Oriented Programming, 22nd European Conference, Paphos, Cyprus, July 7-11, 2008, Proceedings},
	publisher = {Springer},
	author = {Srinivasan, Sriram and Mycroft, Alan},
	editor = {Vitek, Jan},
	date = {2008},
}

@inproceedings{haller_capabilities_2010,
	title = {Capabilities for Uniqueness and Borrowing},
	volume = {6183},
	url = {https://doi.org/10.1007/978-3-642-14107-2\_17},
	doi = {10.1007/978-3-642-14107-2_17},
	series = {Lecture Notes in Computer Science},
	pages = {354--378},
	booktitle = {{ECOOP} 2010 - Object-Oriented Programming, 24th European Conference, Maribor, Slovenia, June 21-25, 2010. Proceedings},
	publisher = {Springer},
	author = {Haller, Philipp and Odersky, Martin},
	editor = {D'Hondt, Theo},
	date = {2010},
}

@inproceedings{charles_x10_2005,
	location = {New York, {NY}, {USA}},
	title = {X10: an object-oriented approach to non-uniform cluster computing},
	isbn = {978-1-59593-031-6},
	url = {https://doi.org/10.1145/1094811.1094852},
	doi = {10.1145/1094811.1094852},
	series = {{OOPSLA} '05},
	shorttitle = {X10},
	pages = {519--538},
	booktitle = {Proceedings of the 20th annual {ACM} {SIGPLAN} conference on Object-oriented programming, systems, languages, and applications},
	publisher = {Association for Computing Machinery},
	author = {Charles, Philippe and Grothoff, Christian and Saraswat, Vijay and Donawa, Christopher and Kielstra, Allan and Ebcioglu, Kemal and von Praun, Christoph and Sarkar, Vivek},
	urldate = {2024-05-13},
	date = {2005-10-12},
	keywords = {atomic blocks, clocks, data distribution, Java, multithreading, non-uniform cluster computing ({NUCC}), partitioned global address space ({PGAS}), places, productivity, scalability, X10},
}

@inproceedings{imam_habanero-java_2014,
	location = {New York, {NY}, {USA}},
	title = {Habanero-Java library: a Java 8 framework for multicore programming},
	isbn = {978-1-4503-2926-2},
	url = {https://dl.acm.org/doi/10.1145/2647508.2647514},
	doi = {10.1145/2647508.2647514},
	series = {{PPPJ} '14},
	shorttitle = {Habanero-Java library},
	abstract = {With the advent of the multicore era, it is clear that future growth in application performance will primarily come from increased parallelism. We believe parallelism should be introduced early into the Computer Science curriculum to educate students on the fundamentals of parallel computation. In this paper, we introduce the newly-created Habanero-Java library ({HJlib}), a pure Java 8 library implementation of the pedagogic parallel programming model [12]. {HJlib} has been used in teaching a sophomore-level course titled "Fundamentals of Parallel Programming" at Rice University. {HJlib} adds to the Java ecosystem a powerful and portable task parallel programming model that can be used to parallelize both regular and irregular applications. By relying on simple orthogonal parallel constructs with important safety properties, {HJlib} allows programmers with a basic knowledge of Java to get started with parallel programming concepts by writing or refactoring applications to harness the power of multicore architecture. The {HJlib} {APIs} make extensive use of lambda expressions and can run on any Java 8 {JVM}. {HJlib} runtime feedback capabilities, such as the abstract execution metrics and the deadlock detector, help the programmer to obtain feedback on theoretical performance as well as the presence of potential bugs in their program. Being an implementation of a pedagogic programming model, {HJlib} is also an attractive tool for both educators and researchers. {HJlib} is actively being used in multiple research projects at Rice and also by external independent collaborators. These projects include exploitation of homogeneous and heterogeneous multicore parallelism in big data applications written for the Hadoop platform [20, 43].},
	pages = {75--86},
	booktitle = {Proceedings of the 2014 International Conference on Principles and Practices of Programming on the Java platform: Virtual machines, Languages, and Tools},
	publisher = {Association for Computing Machinery},
	author = {Imam, Shams and Sarkar, Vivek},
	urldate = {2024-05-13},
	date = {2014-09-23},
	keywords = {Habanero-Java library, Java task parallel library, lambda expressions, task parallelism},
	file = {Full Text PDF:/home/sewi/Zotero/storage/EZK8UIYC/Imam and Sarkar - 2014 - Habanero-Java library a Java 8 framework for mult.pdf:application/pdf},
}

@inproceedings{cave_habanero-java_2011,
	location = {New York, {NY}, {USA}},
	title = {Habanero-Java: the new adventures of old X10},
	isbn = {978-1-4503-0935-6},
	url = {https://dl.acm.org/doi/10.1145/2093157.2093165},
	doi = {10.1145/2093157.2093165},
	series = {{PPPJ} '11},
	shorttitle = {Habanero-Java},
	abstract = {In this paper, we present the Habanero-Java ({HJ}) language developed at Rice University as an extension to the original Java-based definition of the X10 language. {HJ} includes a powerful set of task-parallel programming constructs that can be added as simple extensions to standard Java programs to take advantage of today's multi-core and heterogeneous architectures. The language puts a particular emphasis on the usability and safety of parallel constructs. For example, no {HJ} program using async, finish, isolated, and phaser constructs can create a logical deadlock cycle. In addition, the future and data-driven task variants of the async construct facilitate a functional approach to parallel programming. Finally, any {HJ} program written with async, finish, and phaser constructs that is data-race free is guaranteed to also be deterministic. {HJ} also features two key enhancements that address well known limitations in the use of Java in scientific computing --- the inclusion of complex numbers as a primitive data type, and the inclusion of array-views that support multidimensional views of one-dimensional arrays. The {HJ} compiler generates standard Java class-files that can run on any {JVM} for Java 5 or higher. The {HJ} runtime is responsible for orchestrating the creation, execution, and termination of {HJ} tasks, and features both work-sharing and work-stealing schedulers. {HJ} is used at Rice University as an introductory parallel programming language for second-year undergraduate students. A wide variety of benchmarks have been ported to {HJ}, including a full application that was originally written in Fortran 90. {HJ} has a rich development and runtime environment that includes integration with {DrJava}, the addition of a data race detection tool, and service as a target platform for the Intel Concurrent Collections coordination language},
	pages = {51--61},
	booktitle = {Proceedings of the 9th International Conference on Principles and Practice of Programming in Java},
	publisher = {Association for Computing Machinery},
	author = {Cavé, Vincent and Zhao, Jisheng and Shirako, Jun and Sarkar, Vivek},
	urldate = {2024-05-13},
	date = {2011-08-24},
	keywords = {data-race detection, language, parallel programming},
	file = {Full Text PDF:/home/sewi/Zotero/storage/F83ENDZN/Cavé et al. - 2011 - Habanero-Java the new adventures of old X10.pdf:application/pdf},
}

@article{matsakis_rust_2014,
	title = {The rust language},
	volume = {34},
	issn = {1094-3641},
	url = {https://dl.acm.org/doi/10.1145/2692956.2663188},
	doi = {10.1145/2692956.2663188},
	abstract = {Rust is a new programming language for developing reliable and efficient systems. It is designed to support concurrency and parallelism in building applications and libraries that take full advantage of modern hardware. Rust's static type system is safe1 and expressive and provides strong guarantees about isolation, concurrency, and memory safety. Rust also offers a clear performance model, making it easier to predict and reason about program efficiency. One important way it accomplishes this is by allowing fine-grained control over memory representations, with direct support for stack allocation and contiguous record storage. The language balances such controls with the absolute requirement for safety: Rust's type system and runtime guarantee the absence of data races, buffer overflows, stack overflows, and accesses to uninitialized or deallocated memory.},
	pages = {103--104},
	number = {3},
	journaltitle = {{ACM} {SIGAda} Ada Letters},
	shortjournal = {Ada Lett.},
	author = {Matsakis, Nicholas D. and Klock, Felix S.},
	urldate = {2024-05-13},
	date = {2014-10-18},
	keywords = {affine type systems, memory management, rust, systems programming},
	file = {Full Text PDF:/home/sewi/Zotero/storage/DKKSH6SY/Matsakis and Klock - 2014 - The rust language.pdf:application/pdf},
}

@inproceedings{maffeis_object_2010,
	title = {Object Capabilities and Isolation of Untrusted Web Applications},
	url = {https://ieeexplore.ieee.org/abstract/document/5504710},
	doi = {10.1109/SP.2010.16},
	abstract = {A growing number of current web sites combine active content (applications) from untrusted sources, as in so-called mashups. The object-capability model provides an appealing approach for isolating untrusted content: if separate applications are provided disjoint capabilities, a sound object capability framework should prevent untrusted applications from interfering with each other, without preventing interaction with the user or the hosting page. In developing language-based foundations for isolation proofs based on object-capability concepts, we identify a more general notion of authority safety that also implies resource isolation. After proving that capability safety implies authority safety, we show the applicability of our framework for a specific class of mashups. In addition to proving that a {JavaScript} subset based on Google Caja is capability safe, we prove that a more expressive subset of {JavaScript} is authority safe, even though it is not based on the object-capability model.},
	eventtitle = {2010 {IEEE} Symposium on Security and Privacy},
	pages = {125--140},
	booktitle = {2010 {IEEE} Symposium on Security and Privacy},
	author = {Maffeis, Sergio and Mitchell, John C. and Taly, Ankur},
	urldate = {2024-05-13},
	date = {2010-05},
	note = {{ISSN}: 2375-1207},
	keywords = {Assembly, Capabilities, Computational modeling, Computer architecture, Digital signal processing, Digital signal processing chips, Educational institutions, {JavaScript}, Language-based Security, Large scale integration, Logic, Operational Semantics, Registers, Telecommunication control},
	file = {IEEE Xplore Abstract Record:/home/sewi/Zotero/storage/6VEEMLYF/5504710.html:text/html},
}

@book{miller_robust_2006,
	title = {Robust composition: Towards a unified approach to access control and concurrency control},
	publisher = {Johns Hopkins University},
	author = {Miller, Mark},
	date = {2006},
}

@inproceedings{imam_integrating_2012,
	location = {New York, {NY}, {USA}},
	title = {Integrating task parallelism with actors},
	isbn = {978-1-4503-1561-6},
	url = {https://doi.org/10.1145/2384616.2384671},
	doi = {10.1145/2384616.2384671},
	series = {{OOPSLA} '12},
	abstract = {This paper introduces a unified concurrent programming model combining the previously developed Actor Model ({AM}) and the task-parallel Async-Finish Model ({AFM}). With the advent of multi-core computers, there is a renewed interest in programming models that can support a wide range of parallel programming patterns. The proposed unified model shows how the divide-and-conquer approach of the {AFM} and the no-shared mutable state and event-driven philosophy of the {AM} can be combined to solve certain classes of problems more efficiently and productively than either of the aforementioned models individually. The unified model adds actor creation and coordination to the {AFM}, while also enabling parallelization within actors. This paper describes two implementations of the unified model as extensions of Habanero-Java and Habanero-Scala. The unified model adds to the foundations of parallel programs, and to the tools available for the programmer to aid in productivity and performance while developing parallel software.},
	pages = {753--772},
	booktitle = {Proceedings of the {ACM} international conference on Object oriented programming systems languages and applications},
	publisher = {Association for Computing Machinery},
	author = {Imam, Shams M. and Sarkar, Vivek},
	urldate = {2024-05-13},
	date = {2012-10-19},
	keywords = {parallel programming, actor model, async-finish model, fork-join model, habanero-java, habanero-scala},
}

@inproceedings{imam_habanero-scala_2012,
	title = {Habanero-scala: Async-finish programming in scala},
	booktitle = {The Third Scala Workshop (Scala Days 2012)},
	author = {Imam, Shams and Sarkar, Vivek},
	date = {2012},
}

@book{goetz_java_2006,
	title = {Java Concurrency in Practice},
	isbn = {978-0-321-34960-6},
	publisher = {Addison-Wesley},
	author = {Goetz, Brian and Peierls, Tim and Bloch, Joshua J. and Bowbeer, Joseph and Holmes, David and Lea, Doug},
	date = {2006},
}

@article{honda_multiparty_2016,
	title = {Multiparty Asynchronous Session Types},
	volume = {63},
	doi = {10.1145/2827695},
	pages = {9:1--9:67},
	number = {1},
	journaltitle = {J. {ACM}},
	author = {Honda, Kohei and Yoshida, Nobuko and Carbone, Marco},
	date = {2016},
	file = {Submitted Version:/home/sewi/Zotero/storage/IAGR7BJ3/Honda et al. - 2016 - Multiparty Asynchronous Session Types.pdf:application/pdf},
}

@inproceedings{bocchino_type_2009,
	location = {New York, {NY}, {USA}},
	title = {A type and effect system for deterministic parallel Java},
	isbn = {978-1-60558-766-0},
	url = {https://dl.acm.org/doi/10.1145/1640089.1640097},
	doi = {10.1145/1640089.1640097},
	series = {{OOPSLA} '09},
	abstract = {Today's shared-memory parallel programming models are complex and error-prone.While many parallel programs are intended to be deterministic, unanticipated thread interleavings can lead to subtle bugs and nondeterministic semantics. In this paper, we demonstrate that a practical type and effect system can simplify parallel programming by guaranteeing deterministic semantics with modular, compile-time type checking even in a rich, concurrent object-oriented language such as Java. We describe an object-oriented type and effect system that provides several new capabilities over previous systems for expressing deterministic parallel algorithms.We also describe a language called Deterministic Parallel Java ({DPJ}) that incorporates the new type system features, and we show that a core subset of {DPJ} is sound. We describe an experimental validation showing {thatDPJ} can express a wide range of realistic parallel programs; that the new type system features are useful for such programs; and that the parallel programs exhibit good performance gains (coming close to or beating equivalent, nondeterministic multithreaded programs where those are available).},
	pages = {97--116},
	booktitle = {Proceedings of the 24th {ACM} {SIGPLAN} conference on Object oriented programming systems languages and applications},
	publisher = {Association for Computing Machinery},
	author = {Bocchino, Robert L. and Adve, Vikram S. and Dig, Danny and Adve, Sarita V. and Heumann, Stephen and Komuravelli, Rakesh and Overbey, Jeffrey and Simmons, Patrick and Sung, Hyojin and Vakilian, Mohsen},
	urldate = {2024-05-14},
	date = {2009-10-25},
	keywords = {commutativity, determinism, deterministic parallelism, effect systems, effects},
	file = {Full Text PDF:/home/sewi/Zotero/storage/DN7SSZXA/Bocchino et al. - 2009 - A type and effect system for deterministic paralle.pdf:application/pdf},
}

@inproceedings{vakilian_inferring_2009,
	title = {Inferring method effect summaries for nested heap regions},
	pages = {421--432},
	booktitle = {2009 {IEEE}/{ACM} International Conference on Automated Software Engineering},
	publisher = {{IEEE}},
	author = {Vakilian, Mohsen and Dig, Danny and Bocchino, Robert and Overbey, Jeffrey and Adve, Vikram and Johnson, Ralph},
	date = {2009},
}

@inproceedings{kuper_lvars_2013,
	location = {New York, {NY}, {USA}},
	title = {{LVars}: lattice-based data structures for deterministic parallelism},
	isbn = {978-1-4503-2381-9},
	url = {https://dl.acm.org/doi/10.1145/2502323.2502326},
	doi = {10.1145/2502323.2502326},
	series = {{FHPC} '13},
	shorttitle = {{LVars}},
	abstract = {Programs written using a deterministic-by-construction model of parallel computation are guaranteed to always produce the same observable results, offering programmers freedom from subtle, hard-to-reproduce nondeterministic bugs that are the scourge of parallel software. We present {LVars}, a new model for deterministic-by-construction parallel programming that generalizes existing single-assignment models to allow multiple assignments that are monotonically increasing with respect to a user-specified lattice. {LVars} ensure determinism by allowing only monotonic writes and "threshold" reads that block until a lower bound is reached. We give a proof of determinism and a prototype implementation for a language with {LVars} and describe how to extend the {LVars} model to support a limited form of nondeterminism that admits failures but never wrong answers.},
	pages = {71--84},
	booktitle = {Proceedings of the 2nd {ACM} {SIGPLAN} workshop on Functional high-performance computing},
	publisher = {Association for Computing Machinery},
	author = {Kuper, Lindsey and Newton, Ryan R.},
	urldate = {2024-05-14},
	date = {2013-09-23},
	keywords = {deterministic parallelism, lattices},
	file = {Full Text PDF:/home/sewi/Zotero/storage/NFIRPNR2/Kuper and Newton - 2013 - LVars lattice-based data structures for determini.pdf:application/pdf},
}

@inproceedings{clarke_external_2003,
	location = {Berlin, Heidelberg},
	title = {External Uniqueness Is Unique Enough},
	isbn = {978-3-540-45070-2},
	doi = {10.1007/978-3-540-45070-2_9},
	abstract = {External uniqueness is a surprising new way to add unique references to an {OOPL}. The idea is that an externally unique reference is the only reference into an aggregate from outside the aggregate. Internal references which do not escape the boundary of the aggregate are innocuous and therefore permitted. Based on ownership types, our proposal not only overcomes an abstraction problem from which existing uniqueness proposals suffer, it also enables many examples which are inherently not unique, such as a unique reference to a set of links in a doubly-linked list, without losing the benefits of uniqueness.},
	pages = {176--200},
	booktitle = {{ECOOP} 2003 – Object-Oriented Programming},
	publisher = {Springer},
	author = {Clarke, Dave and Wrigstad, Tobias},
	editor = {Cardelli, Luca},
	date = {2003},
	langid = {english},
	file = {Accepted Version:/home/sewi/Zotero/storage/FVRSU8L4/Clarke and Wrigstad - 2003 - External Uniqueness Is Unique Enough.pdf:application/pdf},
}

@inproceedings{haller_reactive_2016,
	title = {Reactive Async: expressive deterministic concurrency},
	url = {https://doi.org/10.1145/2998392.2998396},
	doi = {10.1145/2998392.2998396},
	pages = {11--20},
	booktitle = {Proceedings of the 7th {ACM} {SIGPLAN} Symposium on Scala, {SCALA}@{SPLASH} 2016, Amsterdam, Netherlands, October 30 - November 4, 2016},
	publisher = {{ACM}},
	author = {Haller, Philipp and Geries, Simon and Eichberg, Michael and Salvaneschi, Guido},
	editor = {Biboudis, Aggelos and Jonnalagedda, Manohar and Stucki, Sandro and Ureche, Vlad},
	date = {2016},
}

@book{arvidsson_deterministic_2018,
	title = {Deterministic Concurrency Using Lattices and the Object Capability Model},
	url = {https://urn.kb.se/resolve?urn=urn:nbn:se:kth:diva-239917},
	abstract = {Parallelization is an important part of modern data systems. However, the non-determinism of thread scheduling introduces the difficult problem of considering all different execution orders when co ...},
	author = {Arvidsson, Ellen},
	urldate = {2024-05-15},
	date = {2018},
	file = {Full Text PDF:/home/sewi/Zotero/storage/5PF236G3/Arvidsson - 2018 - Deterministic Concurrency Using Lattices and the O.pdf:application/pdf},
}

@article{igarashi_featherweight_2001,
	title = {Featherweight Java: a minimal core calculus for Java and {GJ}},
	volume = {23},
	issn = {0164-0925},
	url = {https://dl.acm.org/doi/10.1145/503502.503505},
	doi = {10.1145/503502.503505},
	shorttitle = {Featherweight Java},
	abstract = {Several recent studies have introduced lightweight versions of Java: reduced languages in which complex features like threads and reflection are dropped to enable rigorous arguments about key properties such as type safety. We carry this process a step further, omitting almost all features of the full language (including interfaces and even assignment) to obtain a small calculus, Featherweight Java, for which rigorous proofs are not only possible but easy. Featherweight Java bears a similar relation to Java as the lambda-calculus does to languages such as {ML} and Haskell. It offers a similar computational "feel," providing classes, methods, fields, inheritance, and dynamic typecasts with a semantics closely following Java's. A proof of type safety for Featherweight Java thus illustrates many of the interesting features of a safety proof for the full language, while remaining pleasingly compact. The minimal syntax, typing rules, and operational semantics of Featherweight Java make it a handy tool for studying the consequences of extensions and variations. As an illustration of its utility in this regard, we extend Featherweight Java with generic classes in the style of {GJ} (Bracha, Odersky, Stoutamire, and Wadler) and give a detailed proof of type safety. The extended system formalizes for the first time some of the key features of {GJ}.},
	pages = {396--450},
	number = {3},
	journaltitle = {{ACM} Transactions on Programming Languages and Systems},
	shortjournal = {{ACM} Trans. Program. Lang. Syst.},
	author = {Igarashi, Atsushi and Pierce, Benjamin C. and Wadler, Philip},
	urldate = {2024-05-15},
	date = {2001-05-01},
	keywords = {Java, Compilation, generic classes, language design, language semantics},
	file = {Full Text PDF:/home/sewi/Zotero/storage/LWNAUHTF/Igarashi et al. - 2001 - Featherweight Java a minimal core calculus for Ja.pdf:application/pdf},
}

@inreference{noauthor_forkjoin_2023,
	title = {Fork–join model},
	rights = {Creative Commons Attribution-{ShareAlike} License},
	url = {https://en.wikipedia.org/w/index.php?title=Fork%E2%80%93join_model&oldid=1157279085},
	abstract = {In parallel computing, the fork–join model is a way of setting up and executing parallel programs, such that execution branches off in parallel at designated points in the program, to "join" (merge) at a subsequent point and resume sequential execution. Parallel sections may fork recursively until a certain task granularity is reached.  Fork–join can be considered a parallel design pattern.: 209 ff.  It was formulated as early as 1963.
By nesting fork–join computations recursively, one obtains a parallel version of the divide and conquer paradigm, expressed by the following generic pseudocode:

solve(problem):
    if problem is small enough:
        solve problem directly (sequential algorithm)
    else:
        for part in subdivide(problem)
            fork subtask to solve(part)
        join all subtasks spawned in previous loop
        return combined results},
	booktitle = {Wikipedia},
	urldate = {2024-09-06},
	date = {2023-05-27},
	langid = {english},
	note = {Page Version {ID}: 1157279085},
	file = {Snapshot:/home/sewi/Zotero/storage/AC6C9D5D/Fork–join_model.html:text/html},
}

@article{lee_featherweight_2010,
	title = {Featherweight X10: a core calculus for async-finish parallelism},
	volume = {45},
	issn = {0362-1340},
	url = {https://dl.acm.org/doi/10.1145/1837853.1693459},
	doi = {10.1145/1837853.1693459},
	shorttitle = {Featherweight X10},
	abstract = {We present a core calculus with two of X10's key constructs for parallelism, namely async and finish. Our calculus forms a convenient basis for type systems and static analyses for languages with async-finish parallelism, and for tractable proofs of correctness. For example, we give a short proof of the deadlock-freedom theorem of Saraswat and Jagadeesan. Our main contribution is a type system that solves the open problem of context-sensitive may-happen-in-parallel analysis for languages with async-finish parallelism. We prove the correctness of our type system and we report experimental results of performing type inference on 13,000 lines of X10 code. Our analysis runs in polynomial time, takes a total of 28 seconds on our benchmarks, and produces a low number of false positives, which suggests that our analysis is a good basis for other analyses such as race detectors.},
	pages = {25--36},
	number = {5},
	journaltitle = {{SIGPLAN} Not.},
	author = {Lee, Jonathan K. and Palsberg, Jens},
	urldate = {2024-09-06},
	date = {2010-01-09},
	file = {Full Text PDF:/home/sewi/Zotero/storage/AR4UTI6J/Lee and Palsberg - 2010 - Featherweight X10 a core calculus for async-finis.pdf:application/pdf},
}
